(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{191:function(e,t,o){"use strict";o.r(t),o.d(t,"frontMatter",(function(){return r})),o.d(t,"metadata",(function(){return i})),o.d(t,"rightToc",(function(){return c})),o.d(t,"default",(function(){return u}));var n=o(1),a=o(7),l=(o(0),o(357)),r={id:"java-quick-start",title:"Quick Start"},i={id:"java-quick-start",isDocsHomePage:!1,title:"Quick Start",description:"This topic helps you install the Temporal server and implement a workflow.",source:"@site/docs/java-quick-start.md",permalink:"/docs/next/java-quick-start",editUrl:"https://github.com/temporalio/temporal-documentation-legacy-v2/blob/master/docs/java-quick-start.md",version:"next",sidebar:"docs",previous:{title:"Command Line Interface",permalink:"/docs/next/learn-cli"},next:{title:"Workflow Interface",permalink:"/docs/next/java-workflow-interface"},latestVersionMainDocPermalink:"/docs/overview"},c=[{value:"Install Temporal Server Locally",id:"install-temporal-server-locally",children:[]},{value:"Implement Hello World Java Workflow",id:"implement-hello-world-java-workflow",children:[{value:"Include Temporal Java SDK Dependency",id:"include-temporal-java-sdk-dependency",children:[]},{value:"Implement Hello World Workflow",id:"implement-hello-world-workflow",children:[]},{value:"Execute Hello World Workflow using the CLI",id:"execute-hello-world-workflow-using-the-cli",children:[]},{value:"List Workflows and Workflow History",id:"list-workflows-and-workflow-history",children:[]},{value:"Workflow Id Uniqueness",id:"workflow-id-uniqueness",children:[]},{value:"CLI Help",id:"cli-help",children:[]}]},{value:"Signals",id:"signals",children:[]},{value:"Query",id:"query",children:[]},{value:"Activities",id:"activities",children:[]}],s={rightToc:c};function u(e){var t=e.components,o=Object(a.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},s,o,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"This topic helps you install the Temporal server and implement a workflow."),Object(l.b)("h2",{id:"install-temporal-server-locally"},"Install Temporal Server Locally"),Object(l.b)("p",null,"To run samples locally you need to run Temporal server locally using ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/installing-server"}),"instructions"),"."),Object(l.b)("h2",{id:"implement-hello-world-java-workflow"},"Implement Hello World Java Workflow"),Object(l.b)("h3",{id:"include-temporal-java-sdk-dependency"},"Include Temporal Java SDK Dependency"),Object(l.b)("p",null,"Go to the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://oss.sonatype.org/#nexus-search;quick~temporal-sdk"}),"Maven Repository Temporal Java Client Page"),"\nand find the latest version of the library. Include it as a dependency into your Java project. For example if you\nare using Gradle the dependency looks like:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{}),"    compile group: 'io.temporal', name: 'temporal-sdk', version: '<latest_version>'\n")),Object(l.b)("p",null,"Also add the following dependencies that temporal-sdk relies on:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{}),"    compile group: 'commons-configuration', name: 'commons-configuration', version: '1.9'\n    compile group: 'ch.qos.logback', name: 'logback-classic', version: '1.2.3'\n")),Object(l.b)("p",null,"Make sure that the following code compiles:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"import io.temporal.workflow.Workflow;\nimport io.temporal.workflow.WorkflowMethod;\nimport org.slf4j.Logger;\n\npublic class GettingStarted {\n\n    private static Logger logger = Workflow.getLogger(GettingStarted.class);\n\n    @WorkflowInterface\n    interface HelloWorld {\n        @WorkflowMethod\n        void sayHello(String name);\n    }\n\n}\n")),Object(l.b)("p",null,"If you are having problems setting up the build files use the\n",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/temporalio/temporal-java-samples"}),"Temporal Java Samples")," GitHub repository as a reference."),Object(l.b)("p",null,"Also add the following logback config file somewhere in your classpath:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-xml"}),'<configuration>\n    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">\n        \x3c!-- encoders are assigned the type\n             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --\x3e\n        <encoder>\n            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n        </encoder>\n    </appender>\n    <logger name="io.netty" level="INFO"/>\n    <root level="INFO">\n        <appender-ref ref="STDOUT" />\n    </root>\n</configuration>\n')),Object(l.b)("h3",{id:"implement-hello-world-workflow"},"Implement Hello World Workflow"),Object(l.b)("p",null,"Let's add ",Object(l.b)("inlineCode",{parentName:"p"},"HelloWorldImpl")," with the ",Object(l.b)("inlineCode",{parentName:"p"},"sayHello"),' method that just logs the "Hello ..." and returns.'),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'import io.temporal.worker.Worker;\nimport io.temporal.workflow.Workflow;\nimport io.temporal.workflow.WorkflowMethod;\nimport org.slf4j.Logger;\n\npublic class GettingStarted {\n\n    private static Logger logger = Workflow.getLogger(GettingStarted.class);\n\n    @WorkflowInterface\n    public interface HelloWorld {\n        @WorkflowMethod\n        void sayHello(String name);\n    }\n\n    public static class HelloWorldImpl implements HelloWorld {\n\n        @Override\n        public void sayHello(String name) {\n            logger.info("Hello " + name + "!");\n        }\n    }\n}\n')),Object(l.b)("p",null,"To link the workflow implementation to the Temporal framework, it should be registered with a worker that connects to\na Temporal Service. By default the worker connects to the locally running Temporal service."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'    public static void main(String[] args) {\n        // gRPC stubs wrapper that talks to the local docker instance of temporal service.\n        WorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\n        // client that can be used to start and signal workflows\n        WorkflowClient client = WorkflowClient.newInstance(service);\n        // worker factory that can be used to create workers for specific task queues\n        WorkerFactory factory = WorkerFactory.newInstance(client);\n        Worker worker = factory.newWorker("HelloWorldTaskQueue");\n        worker.registerWorkflowImplementationTypes(HelloWorldImpl.class);\n        factory.start();\n    }\n')),Object(l.b)("h3",{id:"execute-hello-world-workflow-using-the-cli"},"Execute Hello World Workflow using the CLI"),Object(l.b)("p",null,"Now run the worker program. Following is an example log:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"18:39:45.522 [main] INFO  i.t.i.WorkflowServiceStubsImpl - Created GRPC client for channel: ManagedChannelOrphanWrapper{delegate=ManagedChannelImpl{logId=1, target=127.0.0.1:7233}}\n18:39:45.674 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=1, pollThreadNamePrefix='Workflow Poller taskQueue=\"HelloWorldTaskQueue\", namespace=\"default\"'}, identity=unknown-mac}\n18:39:45.676 [main] INFO  io.temporal.internal.worker.Poller - start(): Poller{options=PollerOptions{maximumPollRateIntervalMilliseconds=1000, maximumPollRatePerSecond=0.0, pollBackoffCoefficient=2.0, pollBackoffInitialInterval=PT0.1S, pollBackoffMaximumInterval=PT1M, pollThreadCount=1, pollThreadNamePrefix='null'}, identity=95963a78-641d-434b-841e-a2efe7f8a19f}\n")),Object(l.b)("p",null,"No Hello printed. This is expected because a worker is just a workflow code host. The workflow has to be started to execute. Let's use Temporal CLI to start the workflow:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'> docker run --network=host --rm temporalio/tctl:0.26.0 workflow start --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\"World\\"\nStarted Workflow Id: ef8c6cd6-de62-4481-8398-623865467696, run Id: 26eafcde-6cab-4836-9ad4-888a74e172e1\n')),Object(l.b)("p",null,"The last line of output of the program should now be:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{}),"18:40:28.354 [workflow-1029765531] INFO  main - Hello World!\n")),Object(l.b)("p",null,"Let's start another workflow execution:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'> docker run --network=host --rm temporalio/tctl:0.26.0 workflow start --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\"Temporal\\"\nStarted Workflow Id: 7bdfba1d-b3f4-4665-88c2-cec73301dd52, run Id: d6c99e2d-7d76-458f-956b-a2f72af292bf\n')),Object(l.b)("p",null,"The last two lines of output of the program should now be:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"18:40:28.354 [workflow-1029765531] INFO  main - Hello World!\n18:40:51.678 [workflow-1538256693] INFO  main - Hello Temporal!\n")),Object(l.b)("h3",{id:"list-workflows-and-workflow-history"},"List Workflows and Workflow History"),Object(l.b)("p",null,"Let's list our workflows in the CLI:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),"> docker run --network=host --rm temporalio/tctl:0.26.0 workflow list\n     WORKFLOW TYPE    |             WORKFLOW ID              |                RUN ID                | START TIME | EXECUTION TIME | END TIME\n  HelloWorld_sayHello | 7bdfba1d-b3f4-4665-88c2-cec73301dd52 | d6c99e2d-7d76-458f-956b-a2f72af292bf | 01:40:51   | 01:40:51       | 01:40:51\n  HelloWorld_sayHello | ef8c6cd6-de62-4481-8398-623865467696 | 26eafcde-6cab-4836-9ad4-888a74e172e1 | 01:40:28   | 01:40:28       | 01:40:28\n")),Object(l.b)("p",null,"Now let's look at the workflow execution history:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'> docker run --network=host --rm temporalio/tctl:0.26.0 workflow showid 1965109f-607f-4b14-a5f2-24399a7b8fa7\n  1  EventTypeWorkflowExecutionStarted    {WorkflowType:{Name:HelloWorld_sayHello},\n                                           ParentInitiatedEventId:0, TaskQueue:{Name:HelloWorldTaskQueue,\n                                           Kind:TaskQueueKindNormal}, Input:["Temporal"],\n                                           ExecutionStartToCloseTimeoutSeconds:3600,\n                                           TaskStartToCloseTimeoutSeconds:10,\n                                           Initiator:ContinueAsNewInitiatorDecider,\n                                           ContinuedFailureDetails:[], LastCompletionResult:[],\n                                           OriginalExecutionRunId:d6c99e2d-7d76-458f-956b-a2f72af292bf,\n                                           Identity:tctl@docker-desktop,\n                                           FirstExecutionRunId:d6c99e2d-7d76-458f-956b-a2f72af292bf,\n                                           Attempt:0, ExpirationTimestamp:0,\n                                           FirstDecisionTaskBackoffSeconds:0}\n  2  EventTypeDecisionTaskScheduled       {TaskQueue:{Name:HelloWorldTaskQueue,\n                                           Kind:TaskQueueKindNormal},\n                                           StartToCloseTimeoutSeconds:10,\n                                           Attempt:0}\n  3  EventTypeDecisionTaskStarted         {ScheduledEventId:2, Identity:unknown-mac,\n                                           RequestId:1ef618db-a3ec-45c3-b545-aea5ae5d36fb}\n  4  EventTypeDecisionTaskCompleted       {ExecutionContext:[],\n                                           ScheduledEventId:2,\n                                           StartedEventId:3,\n                                           Identity:unknown-mac}\n  5  EventTypeWorkflowExecutionCompleted  {Result:[],\n                                           DecisionTaskCompletedEventId:4}\n')),Object(l.b)("p",null,"Even for such a trivial workflow, the history gives a lot of useful information. For complex workflows this is a really useful tool for production and development troubleshooting. History can be automatically archived to a long-term blob store (for example Amazon S3) upon workflow completion for compliance, analytical, and troubleshooting purposes."),Object(l.b)("h3",{id:"workflow-id-uniqueness"},"Workflow Id Uniqueness"),Object(l.b)("p",null,"Before proceeding to a more complex workflow implementation, let's take a look at the workflow Id semantic.\nWhen starting a workflow without providing an Id, the client generates one in the form of a UUID. In most real-life scenarios this is not a desired behavior. The business Id should be used instead. Here, we'll specify the Id when starting a workflow:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'> docker run --network=host --rm temporalio/tctl:0.26.0 workflow start  --workflow_id "HelloTemporal1" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\"Temporal\\"\nStarted Workflow Id: HelloTemporal1, run Id: 78ca0a3f-8cd2-46a2-8d23-076c3f0f187c\n')),Object(l.b)("p",null,"Now the list operation is more meaningful as the WORKFLOW ID is our business Id:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),"> docker run --network=host --rm temporalio/tctl:0.26.0 workflow list\n     WORKFLOW TYPE    |      WORKFLOW ID      |                RUN ID                | START TIME | EXECUTION TIME | END TIME\n  HelloWorld_sayHello | HelloTemporal1        | 78ca0a3f-8cd2-46a2-8d23-076c3f0f187c | 01:47:24   | 01:47:24       | 01:47:25\n")),Object(l.b)("p",null,"After the previous one completes, let's try to start another workflow with the same Id:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'> docker run --network=host --rm temporalio/tctl:0.26.0 workflow start  --workflow_id "HelloTemporal1" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\"Temporal\\"\nStarted Workflow Id: HelloTemporal1, run Id: 9b5e36a3-9868-4de5-bbdf-eda9cedcd865\n')),Object(l.b)("p",null,"After the second start the workflow list is:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),"     WORKFLOW TYPE     |      WORKFLOW ID     |                RUN ID                | START TIME | EXECUTION TIME | END TIME\n  HelloWorld_sayHello | HelloTemporal1        | 37a740e5-838c-4020-aed6-1111b0689c38 | 21:11:47   | 21:11:47       | 21:11:47\n  HelloWorld_sayHello | HelloTemporal1        | 75170c60-6d72-48c6-b509-7c9d9f25a8a8 | 21:04:46   | 21:04:46       | 21:04:46\n")),Object(l.b)("p",null,"It might be clear why every workflow has two Ids: Workflow Id and Run Id. Because the Workflow Id can be reused, the Run Id uniquely identifies a particular run of a workflow. Run Id is system generated and cannot be controlled by client code."),Object(l.b)("p",null,"Note - Under no circumstances does Temporal allow more than one instance of an open workflow with the same Id. Multiple workflow Ids are required in the case that paralell invocations wish to be supported (such as an Actor patern)"),Object(l.b)("h3",{id:"cli-help"},"CLI Help"),Object(l.b)("p",null,"See the CLI help command for all of the options supported:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),"> docker run --network=host --rm temporalio/tctl:0.26.0 workflow help start\nNAME:\n   tctl workflow start - start a new workflow execution\n\nUSAGE:\n   tctl workflow start [command options] [arguments...]\n\nOPTIONS:\n   --taskqueue value, --tq value                TaskQueue\n   --workflow_id value, --wid value, -w value  WorkflowId\n   --workflow_type value, --wt value           WorkflowTypeName\n   --execution_timeout value, --et value       Execution start to close timeout in seconds (default: 0)\n   --decision_timeout value, --dt value        Decision task start to close timeout in seconds (default: 10)\n   --cron value                                Optional cron schedule for the workflow. Cron spec is as following:\n                                               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0 - 59)\n                                               \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)\n                                               \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the month (1 - 31)\n                                               \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12)\n                                               \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the week (0 - 6) (Sunday to Saturday)\n                                               \u2502 \u2502 \u2502 \u2502 \u2502\n                                               * * * * *\n   --workflowidreusepolicy value, --wrp value  Optional input to configure if the same workflow Id is allowed to be used for a new workflow execution. Available options: 0: AllowDuplicate, 1: AllowDuplicateFailedOnly, 2: RejectDuplicate (default: 0)\n   --input value, -i value                     Optional input for the workflow, in JSON format. If there are multiple parameters, concatenate them and separate by a space.\n   --input_file value, --if value              Optional input for the workflow from a JSON file. If there are multiple JSON, concatenate them and separate by a space or newline. Input from the file will be overwritten by input from the command line.\n   --memo_key value                            Optional key of memo. If there are multiple keys, concatenate them and separate by space.\n   --memo value                                Optional info that can be shown in list workflow, in JSON format. If there are multiple JSON, concatenate them and separate by a space. The order must be the same as memo_key.\n   --memo_file value                           Optional info that can be listed in list workflow, from JSON format file. If there are multiple JSON, concatenate them and separate by a space or newline. The order must be same as memo_key.\n")),Object(l.b)("h2",{id:"signals"},"Signals"),Object(l.b)("p",null,"So far our workflow is not very interesting. Let's change it to listen on an external event and update state accordingly."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n  }\n\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = "Hello";\n\n    @Override\n    public void sayHello(String name) {\n      int count = 0;\n      while (!"Bye".equals(greeting)) {\n        logger.info(++count + ": " + greeting + " " + name + "!");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + ": " + greeting + " " + name + "!");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n      this.greeting = greeting;\n    }\n  }\n')),Object(l.b)("p",null,'The workflow interface now has a new method annotated with @SignalMethod. It is a callback method that is invoked\nevery time a new signal of "HelloWorld',Object(l.b)("em",{parentName:"p"},'updateGreeting" is delivered to a workflow. The workflow interface can have only\none @WorkflowMethod which is a ',"_","main")," function of the workflow and as many signal methods as needed."),Object(l.b)("p",null,"The updated workflow implementation demonstrates a few important Temporal concepts. The first is that workflow is stateful and can\nhave fields of any complex type. Another is that the ",Object(l.b)("inlineCode",{parentName:"p"},"Workflow.await")," function that blocks until the function it receives as a parameter evaluates to true. The condition is going to be evaluated only on workflow state changes, so it is not a busy wait in traditional sense."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow start  --workflow_id "HelloSignal" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\"World\\"\nStarted Workflow Id: HelloSignal, run Id: 6fa204cb-f478-469a-9432-78060b83b6cd\n')),Object(l.b)("p",null,"Program output:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"16:53:56.120 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 1: Hello World!\n")),Object(l.b)("p",null,"Let's send a signal using CLI:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow signal --workflow_id "HelloSignal" --name "updateGreeting" --input \\"Hi\\"\nSignal workflow succeeded.\n')),Object(l.b)("p",null,"Program output:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"16:53:56.120 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 1: Hello World!\n16:54:57.901 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 2: Hi World!\n")),Object(l.b)("p",null,"Try sending the same signal with the same input again. Note that the output doesn't change. This happens because the await condition\ndoesn't unblock when it sees the same value. But a new greeting unblocks it:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow signal --workflow_id "HelloSignal" --name "updateGreeting" --input \\"Welcome\\"\nSignal workflow succeeded.\n')),Object(l.b)("p",null,"Program output:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"16:53:56.120 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 1: Hello World!\n16:54:57.901 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 2: Hi World!\n16:56:24.400 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 3: Welcome World!\n")),Object(l.b)("p",null,"Now shut down the worker and send the same signal again:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow signal --workflow_id "HelloSignal" --name "updateGreeting" --input \\"Welcome\\"\nSignal workflow succeeded.\n')),Object(l.b)("p",null,"Note that sending signals as well as starting workflows does not need a worker running. The requests are queued inside the Temporal service."),Object(l.b)("p",null,"Now bring the worker back. Note that it doesn't log anything besides the standard startup messages.\nThis occurs because it ignores the queued signal that contains the same input as the current value of greeting.\nNote that the restart of the worker didn't affect the workflow execution. It is still blocked on the same line of code as before the failure.\nThis is the most important feature of Temporal. The workflow code doesn't need to deal with worker failures at all. Its state is fully recovered to its current state that includes all the local variables and threads."),Object(l.b)("p",null,"Let's look at the line where the workflow is blocked:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'> docker run --network=host --rm temporalio/tctl:0.26.0 workflow stack --workflow_id "Hello2"\nQuery result:\n"workflow-root: (BLOCKED on await)\nio.temporal.internal.sync.SyncDecisionContext.await(SyncDecisionContext.java:546)\nio.temporal.internal.sync.WorkflowInternal.await(WorkflowInternal.java:243)\nio.temporal.workflow.Workflow.await(Workflow.java:611)\nio.temporal.samples.hello.GettingStarted$HelloWorldImpl.sayHello(GettingStarted.java:32)\nsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)"\n')),Object(l.b)("p",null,'Yes, indeed the workflow is blocked on await. This feature works for any open workflow, greatly simplifying troubleshooting in production.\nLet\'s complete the workflow by sending a signal with a "Bye" greeting:'),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"16:58:22.962 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 4: Bye World!\n")),Object(l.b)("p",null,"Note that the value of the count variable was not lost during the restart."),Object(l.b)("p",null,"Also note that while a single worker instance is used for this\nwalkthrough, any real production deployment has multiple worker instances running. So any worker failure or restart does not delay any\nworkflow execution because it is just migrated to any other available worker."),Object(l.b)("h2",{id:"query"},"Query"),Object(l.b)("p",null,"So far we have learned that the workflow code is fault tolerant and can update its state in reaction to external events in the form of signals.\nTemporal provides a query feature that supports synchronously returning any information from a workflow to an external caller."),Object(l.b)("p",null,"Update the workflow code to:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'  @WorkflowInterface\n  public interface HelloWorld {\n    @WorkflowMethod\n    void sayHello(String name);\n\n    @SignalMethod\n    void updateGreeting(String greeting);\n\n    @QueryMethod\n    int getCount();\n  }\n\n  public static class HelloWorldImpl implements HelloWorld {\n\n    private String greeting = "Hello";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!"Bye".equals(greeting)) {\n        logger.info(++count + ": " + greeting + " " + name + "!");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      logger.info(++count + ": " + greeting + " " + name + "!");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n      this.greeting = greeting;\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n')),Object(l.b)("p",null,"The new ",Object(l.b)("inlineCode",{parentName:"p"},"getCount")," method annotated with ",Object(l.b)("inlineCode",{parentName:"p"},"@QueryMethod")," was added to the workflow interface definition. It is allowed\nto have multiple query methods per workflow interface."),Object(l.b)("p",null,"The main restriction on the implementation of the query method is that it is not allowed to modify workflow state in any form.\nIt also is not allowed to block its thread in any way. It usually just returns a value derived from the fields of the workflow object.\nLet's run the updated worker and send a couple signals to it:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow start  --workflow_id "HelloQuery" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\"World\\"\nStarted Workflow Id: HelloQuery, run Id: 1925f668-45b5-4405-8cba-74f7c68c3135\ntemporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow signal --workflow_id "HelloQuery" --name "updateGreeting" --input \\"Hi\\"\nSignal workflow succeeded.\ntemporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow signal --workflow_id "HelloQuery" --name "updateGreeting" --input \\"Welcome\\"\nSignal workflow succeeded.\n')),Object(l.b)("p",null,"The worker output:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"17:35:50.485 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 1: Hello World!\n17:36:10.483 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 2: Hi World!\n17:36:16.204 [workflow-root] INFO  c.u.c.samples.hello.GettingStarted - 3: Welcome World!\n")),Object(l.b)("p",null,"Now let's query the workflow using the CLI:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow query --workflow_id "HelloQuery" --query_type "getCount"\nQuery result as JSON:\n3\n')),Object(l.b)("p",null,'One limitation of the query is that it requires a worker process running because it is executing callback code.\nAn interesting feature of the query is that it works for completed workflows as well. Let\'s complete the workflow by sending "Bye" and query it.'),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow signal --workflow_id "HelloQuery" --name "updateGreeting" --input \\"Bye\\"\nSignal workflow succeeded.\ntemporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow query --workflow_id "HelloQuery" --query_type "getCount"\nQuery result as JSON:\n4\n')),Object(l.b)("p",null,"The Query method can accept parameters. This might be useful if only part of the workflow state should be returned."),Object(l.b)("h2",{id:"activities"},"Activities"),Object(l.b)("p",null,"Having fault tolerant code that maintains state, updates it in reaction to external events, and supports querying is already very useful.\nBut in most practical applications, the workflow is expected to act upon the external world. Temporal supports such externally-facing code in the form of activities."),Object(l.b)("p",null,"An activity is essentially a function that can execute any code like DB updates or service calls. The workflow is not allowed to\ndirectly call any external APIs; it can do this only through activities. The workflow is essentially an orchestrator of activities.\nLet's change our program to print the greeting from an activity on every change."),Object(l.b)("p",null,"First let's define an activities interface and implement it:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"  @ActivityInterface\n  public interface HelloWorldActivities {\n    void say(String message);\n  }\n")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"@ActivityInterface")," annotation is required for an activity interface. Each method that belongs to an activity interface\ndefines a separate activity type."),Object(l.b)("p",null,"Activity implementation is just a normal ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Plain_old_Java_object"}),"POJO"),".\nThe ",Object(l.b)("inlineCode",{parentName:"p"},"out")," stream is passed as a parameter to the constructor to demonstrate that the\nactivity object can have any dependencies. Examples of real application dependencies are database connections and service clients."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"  public class HelloWordActivitiesImpl implements HelloWorldActivities {\n    private final PrintStream out;\n\n    public HelloWordActivitiesImpl(PrintStream out) {\n      this.out = out;\n    }\n\n    @Override\n    public void say(String message) {\n      out.println(message);\n    }\n  }\n")),Object(l.b)("p",null,"Let's create a separate main method for the activity worker. It is common to have a single worker that hosts both activities and workflows,\nbut here we keep them separate to demonstrate how Temporal deals with worker failures.\nTo make the activity implementation known to Temporal, register it with the worker:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'public class GettingStartedActivityWorker {\n\n  public static void main(String[] args) {\n    WorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker("HelloWorldTaskQueue");\n    worker.registerActivitiesImplementations(new HelloWordActivitiesImpl(System.out));\n    factory.start();\n  }\n}\n')),Object(l.b)("p",null,"A single instance of an activity object is registered per activity interface type. This means that the activity implementation should be thread-safe since the activity method can be simultaneously called from multiple threads."),Object(l.b)("p",null,"Let's modify the workflow code to invoke the activity instead of logging:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),'  public static class HelloWorldImpl implements HelloWorld {\n\n    private final HelloWorldActivities activities = Workflow.newActivityStub(HelloWorldActivities.class);\n    private String greeting = "Hello";\n    private int count = 0;\n\n    @Override\n    public void sayHello(String name) {\n      while (!"Bye".equals(greeting)) {\n        activities.say(++count + ": " + greeting + " " + name + "!");\n        String oldGreeting = greeting;\n        Workflow.await(() -> !Objects.equals(greeting, oldGreeting));\n      }\n      activities.say(++count + ": " + greeting + " " + name + "!");\n    }\n\n    @Override\n    public void updateGreeting(String greeting) {\n      this.greeting = greeting;\n    }\n\n    @Override\n    public int getCount() {\n      return count;\n    }\n  }\n')),Object(l.b)("p",null,"Activities are invoked through a stub that implements their interface. So an invocation is just a method call on an activity stub."),Object(l.b)("p",null,"Now run the workflow worker. Do not run the activity worker yet. Then start a new workflow execution:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow start  --workflow_id "HelloActivityWorker" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld_sayHello --execution_timeout 3600 --input \\"World\\"\nStarted Workflow Id: HelloActivityWorker, run Id: ff015637-b5af-43e8-b3f6-8b6c7b919b62\n')),Object(l.b)("p",null,"The workflow is started, but nothing visible happens. This is expected as the activity worker is not running. What are the options to understand the currently running workflow state?"),Object(l.b)("p",null,"The first option is look at the stack trace:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow stack  --workflow_id "HelloActivityWorker"\nQuery result as JSON:\n"workflow-root: (BLOCKED on Feature.get)io.temporal.internal.sync.CompletablePromiseImpl.get(CompletablePromiseImpl.java:71)\nio.temporal.internal.sync.ActivityStubImpl.execute(ActivityStubImpl.java:58)\nio.temporal.internal.sync.ActivityInvocationHandler.lambda$invoke$0(ActivityInvocationHandler.java:87)\nio.temporal.internal.sync.ActivityInvocationHandler$$Lambda$25/1816732716.apply(Unknown Source)\nio.temporal.internal.sync.ActivityInvocationHandler.invoke(ActivityInvocationHandler.java:94)\ncom.sun.proxy.$Proxy6.say(Unknown Source)\nio.temporal.samples.hello.GettingStarted$HelloWorldImpl.sayHello(GettingStarted.java:55)\nsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n"\n')),Object(l.b)("p",null,'It shows that the workflow code is blocked on the "say" method of a Proxy object that implements the activity stub.\nYou can restart the workflow worker if you want to make sure that restarting it does not change that. It works for activities\nof any duration. It is okay for the workflow code to block on an activity invocation for a month for example.'),Object(l.b)("p",null,"Another way to see what exactly happened in the workflow execution is to look at the workflow execution history:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow show  --workflow_id "HelloActivityWorker"\n  1  WorkflowExecutionStarted  {WorkflowType:{Name:HelloWorld_sayHello},\n                                TaskQueue:{Name:HelloWorldTaskQueue},\n                                Input:["World"],\n                                ExecutionStartToCloseTimeoutSeconds:3600,\n                                TaskStartToCloseTimeoutSeconds:10,\n                                ContinuedFailureDetails:[],\n                                LastCompletionResult:[],\n                                Identity:temporal-cli@linuxkit-025000000001,\n                                Attempt:0,\n                                FirstDecisionTaskBackoffSeconds:0}\n  2  DecisionTaskScheduled     {TaskQueue:{Name:HelloWorldTaskQueue},\n                                StartToCloseTimeoutSeconds:10,\n                                Attempt:0}\n  3  DecisionTaskStarted       {ScheduledEventId:2,\n                                Identity:36234@maxim-C02XD0AAJGH6,\n                                RequestId:ef645576-7cee-4d2e-9892-597a08b7b01f}\n  4  DecisionTaskCompleted     {ExecutionContext:[],\n                                ScheduledEventId:2,\n                                StartedEventId:3,\n                                Identity:36234@maxim-C02XD0AAJGH6}\n  5  ActivityTaskScheduled     {ActivityId:0,\n                                ActivityType:{Name:HelloWorldActivities_say},\n                                TaskQueue:{Name:HelloWorldTaskQueue},\n                                Input:["1: Hello World!"],\n                                ScheduleToCloseTimeoutSeconds:100,\n                                ScheduleToStartTimeoutSeconds:100,\n                                StartToCloseTimeoutSeconds:100,\n                                HeartbeatTimeoutSeconds:100,\n                                DecisionTaskCompletedEventId:4}\n')),Object(l.b)("p",null,"The last event in the workflow history is ",Object(l.b)("inlineCode",{parentName:"p"},"ActivityTaskScheduled"),". It is recorded when workflow invoked the activity, but it wasn't picked up by an activity worker yet."),Object(l.b)("p",null,"Another useful API is ",Object(l.b)("inlineCode",{parentName:"p"},"DescribeWorkflowExecution")," which, among other information, contains the list of outstanding activities:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow describe  --workflow_id "HelloActivityWorker"\n{\n  "ExecutionConfiguration": {\n    "taskQueue": {\n      "name": "HelloWorldTaskQueue"\n    },\n    "executionStartToCloseTimeoutSeconds": 3600,\n    "taskStartToCloseTimeoutSeconds": 10,\n    "childPolicy": "TERMINATE"\n  },\n  "WorkflowExecutionInfo": {\n    "Execution": {\n      "workflowId": "HelloActivityWorker",\n      "runId": "ff015637-b5af-43e8-b3f6-8b6c7b919b62"\n    },\n    "Type": {\n      "name": "HelloWorld_sayHello"\n    },\n    "StartTime": "2019-06-08T23:56:41Z",\n    "CloseTime": "1970-01-01T00:00:00Z",\n    "Status": null,\n    "HistoryLength": 5,\n    "ParentNamespaceId": null,\n    "ParentExecution": null,\n    "AutoResetPoints": {}\n  },\n  "PendingActivities": [\n    {\n      "ActivityId": "0",\n      "ActivityType": {\n        "name": "HelloWorldActivities_say"\n      },\n      "State": "SCHEDULED",\n      "ScheduledTimestamp": "2019-06-08T23:57:00Z"\n    }\n  ]\n}\n')),Object(l.b)("p",null,"Let's start the activity worker. It starts and immediately prints:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"1: Hello World!\n")),Object(l.b)("p",null,"Let's look at the workflow execution history:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),'temporal: docker run --network=host --rm temporalio/tctl:0.26.0 workflow show  --workflow_id "HelloActivityWorker"\n   1  WorkflowExecutionStarted  {WorkflowType:{Name:HelloWorld_sayHello},\n                                TaskQueue:{Name:HelloWorldTaskQueue},\n                                Input:["World"],\n                                ExecutionStartToCloseTimeoutSeconds:3600,\n                                TaskStartToCloseTimeoutSeconds:10,\n                                ContinuedFailureDetails:[],\n                                LastCompletionResult:[],\n                                Identity:temporal-cli@linuxkit-025000000001,\n                                Attempt:0,\n                                FirstDecisionTaskBackoffSeconds:0}\n   2  DecisionTaskScheduled     {TaskQueue:{Name:HelloWorldTaskQueue},\n                                StartToCloseTimeoutSeconds:10,\n                                Attempt:0}\n   3  DecisionTaskStarted       {ScheduledEventId:2,\n                                Identity:37694@maxim-C02XD0AAJGH6,\n                                RequestId:1d7cba6d-98c8-41fd-91b1-c27dffb21c7f}\n   4  DecisionTaskCompleted     {ExecutionContext:[],\n                                ScheduledEventId:2,\n                                StartedEventId:3,\n                                Identity:37694@maxim-C02XD0AAJGH6}\n   5  ActivityTaskScheduled     {ActivityId:0,\n                                ActivityType:{Name:HelloWorldActivities_say},\n                                TaskQueue:{Name:HelloWorldTaskQueue},\n                                Input:["1: Hello World!"],\n                                ScheduleToCloseTimeoutSeconds:300,\n                                ScheduleToStartTimeoutSeconds:300,\n                                StartToCloseTimeoutSeconds:300,\n                                HeartbeatTimeoutSeconds:300,\n                                DecisionTaskCompletedEventId:4}\n   6  ActivityTaskStarted       {ScheduledEventId:5,\n                                Identity:37784@maxim-C02XD0AAJGH6,\n                                RequestId:a646d5d2-566f-4f43-92d7-6689139ce944,\n                                Attempt:0}\n   7  ActivityTaskCompleted     {Result:[], ScheduledEventId:5,\n                                StartedEventId:6,\n                                Identity:37784@maxim-C02XD0AAJGH6}\n   8  DecisionTaskScheduled     {TaskQueue:{Name:maxim-C02XD0AAJGH6:fd3a85ed-752d-4662-a49d-2665b7667c8a},\n                                StartToCloseTimeoutSeconds:10, Attempt:0}\n   9  DecisionTaskStarted       {ScheduledEventId:8,\n                                Identity:fd3a85ed-752d-4662-a49d-2665b7667c8a,\n                                RequestId:601ef30a-0d1b-4400-b034-65b8328ad34c}\n  10  DecisionTaskCompleted     {ExecutionContext:[],\n                                ScheduledEventId:8,\n                                StartedEventId:9,\n                                Identity:37694@maxim-C02XD0AAJGH6}\n')),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"ActivityTaskStarted")," event is recorded when the activity task is picked up by an activity worker. The Identity field\ncontains the Id of the worker (you can set it to any value on worker startup)."),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"ActivityTaskCompleted")," event is recorded when activity completes. It contains the result of the activity execution."),Object(l.b)("p",null,"Let's look at various failure scenarios. Modify activity task timeout:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"  @ActivityInterface\n  public interface HelloWorldActivities {\n    @ActivityMethod(scheduleToCloseTimeoutSeconds = 100)\n    void say(String message);\n  }\n\n  public class HelloWordActivitiesImpl implements HelloWorldActivities {\n    private final PrintStream out;\n\n    public HelloWordActivitiesImpl(PrintStream out) {\n      this.out = out;\n    }\n\n    @Override\n    public void say(String message) {\n      out.println(message);\n    }\n  }\n")),Object(l.b)("p",null,"(To be continued ...)"))}u.isMDXComponent=!0},357:function(e,t,o){"use strict";o.d(t,"a",(function(){return d})),o.d(t,"b",(function(){return b}));var n=o(0),a=o.n(n);function l(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){l(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function c(e,t){if(null==e)return{};var o,n,a=function(e,t){if(null==e)return{};var o,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)o=l[n],t.indexOf(o)>=0||(a[o]=e[o]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)o=l[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var s=a.a.createContext({}),u=function(e){var t=a.a.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):i({},t,{},e)),o},d=function(e){var t=u(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=Object(n.forwardRef)((function(e,t){var o=e.components,n=e.mdxType,l=e.originalType,r=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=u(o),m=n,b=d["".concat(r,".").concat(m)]||d[m]||p[m]||l;return o?a.a.createElement(b,i({ref:t},s,{components:o})):a.a.createElement(b,i({ref:t},s))}));function b(e,t){var o=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=o.length,r=new Array(l);r[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,r[1]=i;for(var s=2;s<l;s++)r[s]=o[s];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,o)}m.displayName="MDXCreateElement"}}]);