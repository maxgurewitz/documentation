(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{271:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return l})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return p}));var n=a(1),o=a(7),r=(a(0),a(357)),i={id:"learn-cross-dc-replication",title:"Cross-DC Replication"},l={id:"version-0.23.1/learn-cross-dc-replication",isDocsHomePage:!1,title:"Cross-DC Replication",description:"The Temporal Global Namespace feature provides clients with the capability to continue their workflow execution from another",source:"@site/versioned_docs/version-0.23.1/learn-cross-dc-replication.md",permalink:"/docs/0.23.1/learn-cross-dc-replication",editUrl:"https://github.com/temporalio/temporal-documentation-legacy-v2/blob/master/versioned_docs/version-0.23.1/learn-cross-dc-replication.md",version:"0.23.1",sidebar:"version-0.23.1/docs",previous:{title:"Archival",permalink:"/docs/0.23.1/learn-archival"},next:{title:"Filtering Workflows",permalink:"/docs/0.23.1/learn-workflow-filtering"},latestVersionMainDocPermalink:"/docs/overview"},s=[{value:"Global Namespaces Architecture",id:"global-namespaces-architecture",children:[]},{value:"New config for Global Namespaces",id:"new-config-for-global-namespaces",children:[{value:"IsGlobal",id:"isglobal",children:[]},{value:"Clusters",id:"clusters",children:[]},{value:"Active Cluster Name",id:"active-cluster-name",children:[]},{value:"Failover Version",id:"failover-version",children:[]}]},{value:"Conflict Resolution",id:"conflict-resolution",children:[]},{value:"Visibility API",id:"visibility-api",children:[]},{value:"CLI",id:"cli",children:[{value:"Query Global Namespace",id:"query-global-namespace",children:[]},{value:"Failover Global Namespace",id:"failover-global-namespace",children:[]}]},{value:"FAQ",id:"faq",children:[{value:"What happens to outstanding activities after failover?",id:"what-happens-to-outstanding-activities-after-failover",children:[]},{value:"What happens when a start or signal API call is made to a standby cluster?",id:"what-happens-when-a-start-or-signal-api-call-is-made-to-a-standby-cluster",children:[]},{value:"What is the recommended pattern to send external events to an active cluster?",id:"what-is-the-recommended-pattern-to-send-external-events-to-an-active-cluster",children:[]}]}],c={rightToc:s};function p(e){var t=e.components,a=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"The Temporal Global Namespace feature provides clients with the capability to continue their workflow execution from another\ncluster in the event of a datacenter failover. Although you can configure a Global Namespace to be replicated to any number of\nclusters, it is only considered active in a single cluster."),Object(r.b)("h2",{id:"global-namespaces-architecture"},"Global Namespaces Architecture"),Object(r.b)("p",null,"Temporal has introduced a new top level entity, Global Namespaces, which provides support for replication of workflow\nexecution across clusters. Client applications need to run workers polling on Activity/Decision tasks on all clusters.\nTemporal will only dispatch tasks on the current active cluster; workers on the standby cluster will sit idle\nuntil the Global Namespace is failed over."),Object(r.b)("p",null,"Because Temporal is a service that provides highly consistent semantics, we only allow external events like\n",Object(r.b)("strong",{parentName:"p"},"StartWorkflowExecution"),", ",Object(r.b)("strong",{parentName:"p"},"SignalWorkflowExecution"),", etc. on an active cluster. Global Namespaces relies on light-weight\ntransactions (paxos) on the local cluster (Local_Quorum) to update the workflow execution state and create replication\ntasks which are applied asynchronously to replicate state across clusters. If an application makes these API calls on a\ncluster where Global Namespace is in standby mode, Temporal will reject those calls with ",Object(r.b)("strong",{parentName:"p"},"NamespaceNotActiveError"),", which\ncontains the name of the current active cluster. It is the responsibility of the application to forward the external\nevent to the cluster that is currently active."),Object(r.b)("h2",{id:"new-config-for-global-namespaces"},"New config for Global Namespaces"),Object(r.b)("h3",{id:"isglobal"},"IsGlobal"),Object(r.b)("p",null,"This config is used to distinguish namespaces local to the cluster from the global namespace. It controls the creation of\nreplication tasks on updates allowing the state to be replicated across clusters. This is a read-only setting that can\nonly be set when the namespace is provisioned."),Object(r.b)("h3",{id:"clusters"},"Clusters"),Object(r.b)("p",null,"A list of clusters where the namespace can fail over to, including the current active cluster.\nThis is also a read-only setting that can only be set when the namespace is provisioned. A re-replication feature on the\nroadmap will allow updating this config to add/remove clusters in the future."),Object(r.b)("h3",{id:"active-cluster-name"},"Active Cluster Name"),Object(r.b)("p",null,"Name of the current active cluster for the Global Namespace. This config is updated each time the Global Namespace is failed over to\nanother cluster."),Object(r.b)("h3",{id:"failover-version"},"Failover Version"),Object(r.b)("p",null,"Unique failover version which also represents the current active cluster for Global Namespace. Temporal allows failover to\nbe triggered from any cluster, so failover version is designed in a way to not allow conflicts if failover is mistakenly\ntriggered simultaneously on two clusters."),Object(r.b)("h2",{id:"conflict-resolution"},"Conflict Resolution"),Object(r.b)("p",null,"Unlike local namespaces which provide at-most-once semantics for activity execution, Global Namespaces can only support at-least-once\nsemantics. Temporal XDC relies on asynchronous replication of events across clusters, so in the event of a failover\nit is possible that activity gets dispatched again on the new active cluster due to a replication task lag. This also\nmeans that whenever workflow execution is updated after a failover by the new cluster, any previous replication tasks\nfor that execution cannot be applied. This results in loss of some progress made by the workflow execution in the\nprevious active cluster. During such conflict resolution, Temporal re-injects any external events like Signals to the\nnew history before discarding replication tasks. Even though some progress could rollback during failovers, Temporal\nprovides the guarantee that workflows won\u2019t get stuck and will continue to make forward progress."),Object(r.b)("h2",{id:"visibility-api"},"Visibility API"),Object(r.b)("p",null,"All Visibility APIs are allowed on both active and standby clusters. This enables\n",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/temporalio/temporal-web"}),"Temporal Web")," to work seamlessly for Global Namespaces as all visibility records for\nworkflow executions can be queried from any cluster the namespace is replicated to. Applications making API calls directly\nto the Temporal Visibility API will continue to work even if a Global Namespace is in standby mode. However, they might see\na lag due to replication delay when querying the workflow execution state from a standby cluster."),Object(r.b)("h2",{id:"cli"},"CLI"),Object(r.b)("p",null,"The Temporal CLI can also be used to query the namespace config or perform failovers. Here are some useful commands."),Object(r.b)("h3",{id:"query-global-namespace"},"Query Global Namespace"),Object(r.b)("p",null,"The following command can be used to describe Global Namespace metadata:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),"$ tctl --ns temporal-canary-xdc n desc\nName: temporal-canary-xdc\nDescription: temporal canary cross dc testing namespace\nOwnerEmail: temporal-dev@temporal.io\nNamespaceData:\nStatus: REGISTERED\nRetentionInDays: 7\nEmitMetrics: true\nActiveClusterName: dc1\nClusters: dc1, dc2\n")),Object(r.b)("h3",{id:"failover-global-namespace"},"Failover Global Namespace"),Object(r.b)("p",null,"The following command can be used to failover Global Namespace ",Object(r.b)("em",{parentName:"p"},"my-namespace-global")," to the ",Object(r.b)("em",{parentName:"p"},"dc2")," cluster:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),"$ tctl --ns my-namespace-global n up --ac dc2\n")),Object(r.b)("h2",{id:"faq"},"FAQ"),Object(r.b)("h3",{id:"what-happens-to-outstanding-activities-after-failover"},"What happens to outstanding activities after failover?"),Object(r.b)("p",null,"Temporal does not forward activity completions across clusters. Any outstanding activity will eventually timeout based\non the configuration. Your application should have retry logic in place so that the activity gets retried and dispatched\nagain to a worker after the failover to the new DC. Handling this is pretty much the same as activity timeout caused by\na worker restart even without Global Namespaces."),Object(r.b)("h3",{id:"what-happens-when-a-start-or-signal-api-call-is-made-to-a-standby-cluster"},"What happens when a start or signal API call is made to a standby cluster?"),Object(r.b)("p",null,"Temporal will reject the call and return ",Object(r.b)("strong",{parentName:"p"},"NamespaceNotActiveError"),". It is the responsibility of the application to forward\nthe failed call to active cluster based on information provided in the error."),Object(r.b)("h3",{id:"what-is-the-recommended-pattern-to-send-external-events-to-an-active-cluster"},"What is the recommended pattern to send external events to an active cluster?"),Object(r.b)("p",null,"The recommendation at this point is to publish events to a Kafka topic if they can be generated in any DC.\nThen, have a consumer that consumes from the aggregated Kafka topic in the same DC and sends them to Temporal. Both the\nKafka consumer and Global Namespace need to be failed over together."))}p.isMDXComponent=!0},357:function(e,t,a){"use strict";a.d(t,"a",(function(){return u})),a.d(t,"b",(function(){return b}));var n=a(0),o=a.n(n);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var c=o.a.createContext({}),p=function(e){var t=o.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):l({},t,{},e)),a},u=function(e){var t=p(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},h=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(a),h=n,b=u["".concat(i,".").concat(h)]||u[h]||d[h]||r;return a?o.a.createElement(b,l({ref:t},c,{components:a})):o.a.createElement(b,l({ref:t},c))}));function b(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var c=2;c<r;c++)i[c]=a[c];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,a)}h.displayName="MDXCreateElement"}}]);